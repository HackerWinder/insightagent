"""
任务管理服务
"""
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, desc
import uuid
import logging
from datetime import datetime, timezone

from app.models.task import Task, TaskLog, TaskStatus, LogLevel
from app.schemas.task import TaskCreate, TaskUpdate
from app.core.config import settings
from app.services.queue_manager import task_queue, QueuePriority
from app.services.websocket_manager import websocket_notifier

logger = logging.getLogger(__name__)


class TaskManager:
    """任务管理器"""
    
    def __init__(self, db: Session):
        self.db = db
    
    async def create_task(self, task_data: TaskCreate, user_id: str) -> Task:
        """
        创建新的分析任务
        
        Args:
            task_data: 任务创建数据
            user_id: 用户ID
            
        Returns:
            创建的任务对象
        """
        try:
            # 创建任务实例
            db_task = Task(
                user_id=user_id,
                product_name=task_data.product_name,
                status=TaskStatus.QUEUED,
                progress=0.0
            )
            
            # 保存到数据库
            self.db.add(db_task)
            self.db.commit()
            self.db.refresh(db_task)
            
            # 记录任务创建日志
            await self.add_task_log(
                task_id=db_task.id,
                level=LogLevel.INFO,
                message=f"任务已创建: {task_data.product_name}",
                step="task_creation"
            )
            
            # 将任务加入执行队列
            await self._enqueue_task_for_processing(db_task)
            
            logger.info(f"Task created: {db_task.id} for product: {task_data.product_name}")
            
            return db_task
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to create task: {e}")
            raise
    
    async def get_tasks(
        self,
        user_id: str,
        page: int = 1,
        page_size: int = 10,
        status: Optional[TaskStatus] = None,
        product_name: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        获取用户的任务列表
        
        Args:
            user_id: 用户ID
            page: 页码
            page_size: 每页数量
            status: 状态筛选
            product_name: 产品名称筛选
            
        Returns:
            包含任务列表和分页信息的字典
        """
        try:
            # 构建查询
            query = self.db.query(Task).filter(Task.user_id == user_id)
            
            # 按状态筛选
            if status:
                query = query.filter(Task.status == status)
            
            # 按产品名称筛选
            if product_name:
                query = query.filter(Task.product_name.ilike(f"%{product_name}%"))
            
            # 计算总数
            total = query.count()
            
            # 分页查询
            offset = (page - 1) * page_size
            tasks = query.order_by(desc(Task.created_at)).offset(offset).limit(page_size).all()
            
            return {
                "tasks": tasks,
                "total": total,
                "page": page,
                "page_size": page_size,
                "total_pages": (total + page_size - 1) // page_size
            }
            
        except Exception as e:
            logger.error(f"Failed to get tasks for user {user_id}: {e}")
            raise
    
    async def get_task_by_id(self, task_id: uuid.UUID, user_id: str) -> Optional[Task]:
        """
        根据ID获取任务
        
        Args:
            task_id: 任务ID
            user_id: 用户ID
            
        Returns:
            任务对象或None
        """
        try:
            task = self.db.query(Task).filter(
                and_(Task.id == task_id, Task.user_id == user_id)
            ).first()
            
            return task
            
        except Exception as e:
            logger.error(f"Failed to get task {task_id}: {e}")
            raise
    
    async def update_task(
        self,
        task_id: uuid.UUID,
        task_update: TaskUpdate,
        user_id: str
    ) -> Optional[Task]:
        """
        更新任务
        
        Args:
            task_id: 任务ID
            task_update: 更新数据
            user_id: 用户ID
            
        Returns:
            更新后的任务对象或None
        """
        try:
            # 查询任务
            task = await self.get_task_by_id(task_id, user_id)
            if not task:
                return None
            
            # 记录状态变更
            old_status = task.status
            
            # 更新字段
            update_data = task_update.dict(exclude_unset=True)
            for field, value in update_data.items():
                setattr(task, field, value)
            
            # 更新时间戳
            task.updated_at = datetime.now(timezone.utc)
            
            # 保存更改
            self.db.commit()
            self.db.refresh(task)
            
            # 记录状态变更日志和通知
            if 'status' in update_data and old_status != task.status:
                await self.add_task_log(
                    task_id=task.id,
                    level=LogLevel.INFO,
                    message=f"任务状态从 {old_status.value} 变更为 {task.status.value}",
                    step="status_change"
                )
                
                # 发送WebSocket通知
                await websocket_notifier.notify_task_status_change(
                    task_id=str(task.id),
                    user_id=task.user_id,
                    status=task.status.value,
                    progress=task.progress,
                    message=f"任务状态已更新为 {task.status.value}"
                )
            
            logger.info(f"Task {task_id} updated successfully")
            
            return task
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to update task {task_id}: {e}")
            raise
    
    async def delete_task(self, task_id: uuid.UUID, user_id: str) -> bool:
        """
        删除任务
        
        Args:
            task_id: 任务ID
            user_id: 用户ID
            
        Returns:
            是否删除成功
        """
        try:
            # 查询任务
            task = await self.get_task_by_id(task_id, user_id)
            if not task:
                return False
            
            # 检查任务状态，只允许删除已完成或失败的任务
            if task.status == TaskStatus.RUNNING:
                logger.warning(f"Cannot delete running task {task_id}")
                return False
            
            # 删除任务（级联删除相关数据）
            self.db.delete(task)
            self.db.commit()
            
            logger.info(f"Task {task_id} deleted successfully")
            
            return True
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to delete task {task_id}: {e}")
            raise
    
    async def add_task_log(
        self,
        task_id: uuid.UUID,
        level: LogLevel,
        message: str,
        step: Optional[str] = None
    ) -> TaskLog:
        """
        添加任务日志
        
        Args:
            task_id: 任务ID
            level: 日志级别
            message: 日志消息
            step: 执行步骤
            
        Returns:
            创建的日志对象
        """
        try:
            log = TaskLog(
                task_id=task_id,
                level=level,
                message=message,
                step=step
            )
            
            self.db.add(log)
            self.db.commit()
            self.db.refresh(log)
            
            # 发送WebSocket日志通知
            try:
                # 获取任务信息以获取用户ID
                task = self.db.query(Task).filter(Task.id == task_id).first()
                if task:
                    await websocket_notifier.notify_task_log(
                        task_id=str(task_id),
                        user_id=task.user_id,
                        level=level.value,
                        message=message,
                        step=step
                    )
            except Exception as e:
                logger.error(f"Failed to send WebSocket log notification: {e}")
            
            return log
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to add task log: {e}")
            raise
    
    async def get_task_logs(
        self,
        task_id: uuid.UUID,
        user_id: str,
        limit: int = 100,
        level: Optional[LogLevel] = None
    ) -> List[TaskLog]:
        """
        获取任务日志
        
        Args:
            task_id: 任务ID
            user_id: 用户ID
            limit: 日志条数限制
            level: 日志级别筛选
            
        Returns:
            日志列表
        """
        try:
            # 验证任务存在且属于当前用户
            task = await self.get_task_by_id(task_id, user_id)
            if not task:
                return []
            
            # 构建查询
            query = self.db.query(TaskLog).filter(TaskLog.task_id == task_id)
            
            # 按级别筛选
            if level:
                query = query.filter(TaskLog.level == level)
            
            # 获取日志
            logs = query.order_by(desc(TaskLog.timestamp)).limit(limit).all()
            
            return logs
            
        except Exception as e:
            logger.error(f"Failed to get task logs for {task_id}: {e}")
            raise
    
    async def get_user_task_stats(self, user_id: str) -> Dict[str, Any]:
        """
        获取用户任务统计信息
        
        Args:
            user_id: 用户ID
            
        Returns:
            统计信息字典
        """
        try:
            # 查询各状态任务数量
            stats = {}
            for status in TaskStatus:
                count = self.db.query(Task).filter(
                    and_(Task.user_id == user_id, Task.status == status)
                ).count()
                stats[status.value.lower()] = count
            
            # 总任务数
            stats['total'] = sum(stats.values())
            
            # 最近任务
            recent_task = self.db.query(Task).filter(
                Task.user_id == user_id
            ).order_by(desc(Task.created_at)).first()
            
            stats['last_task_created'] = recent_task.created_at.isoformat() if recent_task else None
            
            return stats
            
        except Exception as e:
            logger.error(f"Failed to get task stats for user {user_id}: {e}")
            raise
    
    async def cancel_task(self, task_id: uuid.UUID, user_id: str) -> bool:
        """
        取消任务
        
        Args:
            task_id: 任务ID
            user_id: 用户ID
            
        Returns:
            是否取消成功
        """
        try:
            # 查询任务
            task = await self.get_task_by_id(task_id, user_id)
            if not task:
                return False
            
            # 只能取消排队中或运行中的任务
            if task.status not in [TaskStatus.QUEUED, TaskStatus.RUNNING]:
                logger.warning(f"Cannot cancel task {task_id} with status {task.status}")
                return False
            
            # 更新任务状态
            task.status = TaskStatus.FAILED
            task.error_message = "任务已被用户取消"
            task.updated_at = datetime.now(timezone.utc)
            
            self.db.commit()
            
            # 记录取消日志
            await self.add_task_log(
                task_id=task.id,
                level=LogLevel.WARNING,
                message="任务已被用户取消",
                step="task_cancellation"
            )
            
            logger.info(f"Task {task_id} cancelled by user")
            
            return True
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to cancel task {task_id}: {e}")
            raise
    
    async def retry_task(self, task_id: uuid.UUID, user_id: str) -> bool:
        """
        重试失败的任务
        
        Args:
            task_id: 任务ID
            user_id: 用户ID
            
        Returns:
            是否重试成功
        """
        try:
            # 查询任务
            task = await self.get_task_by_id(task_id, user_id)
            if not task:
                return False
            
            # 只能重试失败的任务
            if task.status != TaskStatus.FAILED:
                logger.warning(f"Cannot retry task {task_id} with status {task.status}")
                return False
            
            # 重置任务状态
            task.status = TaskStatus.QUEUED
            task.progress = 0.0
            task.error_message = None
            task.updated_at = datetime.now(timezone.utc)
            
            self.db.commit()
            
            # 记录重试日志
            await self.add_task_log(
                task_id=task.id,
                level=LogLevel.INFO,
                message="任务已重新排队等待执行",
                step="task_retry"
            )
            
            # 将任务重新加入执行队列
            await self._enqueue_task_for_processing(task)
            
            logger.info(f"Task {task_id} queued for retry")
            
            return True
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to retry task {task_id}: {e}")
            raise    

    async def _enqueue_task_for_processing(self, task: Task) -> bool:
        """
        将任务加入处理队列
        
        Args:
            task: 任务对象
            
        Returns:
            是否成功加入队列
        """
        try:
            # 构建任务数据
            task_data = {
                "task_id": str(task.id),
                "user_id": task.user_id,
                "product_name": task.product_name,
                "created_at": task.created_at.isoformat()
            }
            
            # 根据任务类型确定优先级（这里可以根据业务需求调整）
            priority = QueuePriority.NORMAL
            
            # 加入队列
            success = await task_queue.enqueue_task(
                task_id=str(task.id),
                task_data=task_data,
                priority=priority
            )
            
            if success:
                await self.add_task_log(
                    task_id=task.id,
                    level=LogLevel.INFO,
                    message="任务已加入执行队列",
                    step="queue_enqueue"
                )
            
            return success
            
        except Exception as e:
            logger.error(f"Failed to enqueue task {task.id}: {e}")
            return False
    
    async def get_queue_stats(self) -> Dict[str, Any]:
        """
        获取队列统计信息
        
        Returns:
            队列统计信息
        """
        try:
            return await task_queue.get_queue_stats()
        except Exception as e:
            logger.error(f"Failed to get queue stats: {e}")
            return {}
    
    async def get_failed_tasks_from_queue(self, limit: int = 100) -> List[Dict[str, Any]]:
        """
        获取队列中的失败任务
        
        Args:
            limit: 返回数量限制
            
        Returns:
            失败任务列表
        """
        try:
            return await task_queue.get_failed_tasks(limit)
        except Exception as e:
            logger.error(f"Failed to get failed tasks from queue: {e}")
            return []
    
    async def clear_failed_queue(self) -> int:
        """
        清空失败任务队列
        
        Returns:
            清理的任务数量
        """
        try:
            return await task_queue.clear_failed_tasks()
        except Exception as e:
            logger.error(f"Failed to clear failed queue: {e}")
            return 0